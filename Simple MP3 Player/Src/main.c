/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


/* ======= STD & Bit Math ======= */
#include "BIT_MATH.h"
#include "STD_TYPES.h"
/* ======= MCAL DRIVERS ======= */
#include "RCC_interface.h"
#include "GPIO_interface.h"
#include "NVIC_interface.h"
#include "EXTI_interface.h"
#include "STK_interface.h"
//#include "DMA_interface.h"


#include "ADC_interface.h"
/* ======= HAL DRIVERS ======= */
//#include "Segment_interface.h"
//#include "KEYPAD_interface.h"
//#include <stdio.h>


#include "2dene2lbak.h"
//#include "file.h"

#define Pause_Button PIN0
#define Play_Button PIN1
#define Stop_Button PIN5

volatile u16 i = 0 ;

typedef enum {
	STOP,
	PLAY,
	PAUSE,
}mp3_state;

void DAC_voidSong(void)
{   mp3_state state;
	state =	PLAY;
	MGPIO_voidSetPortValue(GPIO_PORTA,adene2lbak_raw[i] );
	if (MGPIO_u8GetPinValue(GPIO_PORTB, Play_Button)==LOW)
		state = PLAY;
	else if (MGPIO_u8GetPinValue(GPIO_PORTB, Pause_Button)==LOW)
		state = PAUSE;
	else if (MGPIO_u8GetPinValue(GPIO_PORTB, Stop_Button)==LOW)
		state = STOP;

	switch(state)
	{
		case PLAY:
		i++;
		if (i   ==   36688)
		{
			i=0;
		}
		break;

		case PAUSE:
		while (MGPIO_u8GetPinValue(GPIO_PORTB, Play_Button)== HIGH && MGPIO_u8GetPinValue(GPIO_PORTB, Stop_Button)==HIGH);
		break;

		case STOP:
		while (MGPIO_u8GetPinValue(GPIO_PORTB, Play_Button)== HIGH );
		i = 0;
		break;
	}
}
int main(void)
{
		/************* RCC *************/
		MRCC_voidInit();
		MRCC_voidEnablePeripheralClock(RCC_APB2, RCC_GPIOA);
		MRCC_voidEnablePeripheralClock(RCC_APB2, RCC_GPIOB);

		/************* GPIO  *************/
		MGPIO_voidSetPortDirection(GPIO_PORTA, OUTPUT_PORT_2MHZ_PP);
	    MGPIO_voidSetPinDirection(GPIO_PORTB,Pause_Button, INPUT_PULLUP_PULLDOWN); //Pause Button
		MGPIO_voidSetPinDirection(GPIO_PORTB, Play_Button, INPUT_PULLUP_PULLDOWN); //Play  Button
		MGPIO_voidSetPinDirection(GPIO_PORTB, Stop_Button, INPUT_PULLUP_PULLDOWN); //Stop  Button
		MGPIO_voidSetPinValue(GPIO_PORTB,Pause_Button, HIGH);
		MGPIO_voidSetPinValue(GPIO_PORTB, Play_Button, HIGH);
		MGPIO_voidSetPinValue(GPIO_PORTB, Stop_Button, HIGH);

		/************* STK  *************/
		MSTK_voidInit();
		MSTK_voidSetIntervalPeriodicMicro( 125, DAC_voidSong );

		while(1)
		{
			//MSTK_voidSetIntervalSingleMicro(125,DAC_voidSong);
		}
	}
